09 分布式事务项目
	 07  base理论 

	 06  分布式考虑的问题  CAP(本身矛盾)
		如果你保证了AP,就无法再保证数据的一致性,通过写和读来掩饰

		一致性   C
		可用性   A
		节点通信 (分区容错 脑裂)  P
		

         05 分布式事务解决方案
		
		4.gts
		3.saga(美团)
		2.TCC
		1.二段提交


	 04 处理这种分布式事务的问题一定要学会演示理解
		减库存与生成订单的问题来演示分布式事务
		

	 03 zookeeper里面的ls命令可以查看注册节点信息

	 02 读取远程配置文件失败还可以覆盖本地的配置中心文件

	 01 配置中心的用户名密码竟然可以使用密文的形式
	 
08 源码阅读

07 领域驱动

06 对象存储,块存储,文件存储
	fastdfs 是文件存储
	当然，对于不同的软件系统来说，一次访问需要获取的不一定是单个我们传统意义上的文件，
	根据不同的需要可能只是一个/组值，某个文件的一部分，也可能是多个文件的组合，
	甚至是某个块设备，统称为对象。这就是对象存储。
	

05 sql执行的性能分析
		

04 视图和物化视图
	

	02 
		普通视图和物化视图的区别
		普通视图和物化视图根本就不是一个东西，说区别都是硬拼到一起的，
		首先明白基本概念，普通视图是不存储任何数据的，他只有定义，在查询中是转换为对应的定义SQL去查询，
		而物化视图是将数据转换为一个表，实际存储着数据，这样查询数据，就不用关联一大堆表，如果表很大的话，
		会在临时表空间内做大量的操作。

	01	物化视图
		物化视图的特点：
		(1) 物化视图在某种意义上说就是一个物理表(而且不仅仅是一个物理表)，这通过其可以被user_tables查询出来，而得到佐证； 
		(2) 物化视图也是一种段(segment)，所以其有自己的物理存储属性； 
		(3) 物化视图会占用数据库磁盘空间，这点从user_segment的查询结果，可以得到佐证； 
		创建语句：create materialized view mv_name as select * from table_name 
		默认情况下，如果没指定刷新方法和刷新模式，则Oracle默认为FORCE和DEMAND。
		


03 索引的知识
	02	聚集索引
		MySQL 索引类型有：唯一索引，主键（聚集）索引，非聚集索引，全文索引。
		
		定义：数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。

		非聚集索引
		该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引

		聚集索引效率高于非聚集索引
		
	01 男女字段不适合加索引
		不适合加索引

02 消息安全
	03 重复消息的解决方案
		造成消息重复的根本原因是：网络不可达。只要通过网络交换数据，就无法避免这个问题。所以解决这个问题的办
		法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？	
		
		1. 消费端处理消息的业务逻辑保持幂等性
		2. 保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现
		
		1. 消费端处理消息的业务逻辑保持幂等性
		2. 保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现
		第1条很好理解，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。第2条原理就是利用一张日志
		表来记录已经处理成功的消息的ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息。
		第1条解决方案，很明显应该在消费端实现，不属于消息系统要实现的功能。第2条可以消息系统实现，也可以业务
		端实现。正常情况下出现重复消息的概率其实很小，如果由消息系统来实现的话，肯定会对消息系统的吞吐量和高
		可用有影响，所以最好还是由业务端自己处理消息重复的问题，这也是RocketMQ不解决消息重复的问题的原因。
		

	02 分布式事务流程
		. 发送方向 MQ 服务端发送消息。
	2. MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功，此时消息为半消息。
	3. 发送方开始执行本地事务逻辑。
	4. 发送方根据本地事务执行结果向 MQ Server 提交二次确认（Commit 或是 Rollback），MQ Server 收到
	Commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 Rollback 状态则删除半
	消息，订阅方将不会接受该消息。
	5. 在断网或者是应用重启的特殊情况下，上述步骤4提交的二次确认最终未到达 MQ Server，经过固定时间后
	MQ Server 将对该消息发起消息回查。
	6. 发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。
	7. 发送方根据检查得到的本地事务的最终状态再次提交二次确认，MQ Server 仍按照步骤4对半消息进行操作。

		
	01 半消息
	由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，MQ 服务端通过扫描发现某条消息长
	期处于“半消息”时，需要主动向消息生产者询问该消息的最终状态（Commit 或是 Rollback），该过程即消息回
	查。

	指的是暂不能投递的消息，发送方已经将消息成功发送到了 MQ 服务端，但是服务端未收到生产者对该消息的二次
	确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的消息即半消息。

01 分布式事务的处理方式
	消息队列