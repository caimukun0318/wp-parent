	

004 如何防止出现死锁
	死锁（Deadlock）

所谓死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。 一种情形，此时执行程序中两个或多个线程发生永久堵塞（等待），每个线程都在等待被其他线程占用并堵塞了的资源。例如，如果线程A锁住了记录1并等待记录2，而线程B锁住了记录2并等待记录1，这样两个线程就发生了死锁现象。计算机系统中,如果系统的资源分配策略不当，更常见的可能是程序员写的程序有错误等，则会导致进程因竞争资源不当而产生死锁的现象。锁有多种实现方式，比如意向锁，共享－排他锁，锁表，树形协议，时间戳协议等等。锁还有多种粒度，比如可以在表上加锁，也可以在记录上加锁。 

产生死锁的原因主要是：

（1）系统资源不足。

（2） 进程运行推进的顺序不合适。

（3）资源分配不当等。

	如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。

	产生死锁的四个必要条件：

	（1） 互斥条件：一个资源每次只能被一个进程使用。
	（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
	（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
	（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

	  这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。

	死锁的预防和解除：

	理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源,在系统运行过程中，对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，若分配后系统可能发生死锁，则不予分配，否则予以分配 。因此，对资源的分配要给予合理的规划。
	 

	如何将死锁减至最少

	虽然不能完全避免死锁，但可以使死锁的数量减至最少。将死锁减至最少可以增加事务的吞吐量并减少系统开销，因为只有很少的事务回滚，而回滚会取消事务执行的所有工作。由于死锁时回滚而由应用程序重新提交。

	下列方法有助于最大限度地降低死锁：

	（1）按同一顺序访问对象。

	（2）避免事务中的用户交互。

	（3）保持事务简短并在一个批处理中。

	（4）使用低隔离级别。

	（5）使用绑定连接。

	1、按同一顺序访问对象

	如果所有并发事务按同一顺序访问对象，则发生死锁的可能性会降低。例如，如果两个并发事务获得 Supplier 表上的锁，然后获得 Part 表上的锁，则在其中一个事务完成之前，另一个事务被阻塞在 Supplier 表上。第一个事务提交或回滚后，第二个事务继续进行。不发生死锁。将存储过程用于所有的数据修改可以标准化访问对象的顺序。

	2、避免事务中的用户交互

	避免编写包含用户交互的事务，因为运行没有用户交互的批处理的速度要远远快于用户手动响应查询的速度，例如答复应用程序请求参数的提示。例如，如果事务正在等待用户输入，而用户去吃午餐了或者甚至回家过周末了，则用户将此事务挂起使之不能完成。这样将降低系统的吞吐量，因为事务持有的任何锁只有在事务提交或回滚时才会释放。即使不出现死锁的情况，访问同一资源的其它事务也会被阻塞，等待该事务完成。

	3、保持事务简短并在一个批处理中

	在同一数据库中并发执行多个需要长时间运行的事务时通常发生死锁。事务运行时间越长，其持有排它锁或更新锁的时间也就越长，从而堵塞了其它活动并可能导致死锁。

	保持事务在一个批处理中，可以最小化事务的网络通信往返量，减少完成事务可能的延迟并释放锁。

	4、使用低隔离级别

	确定事务是否能在更低的隔离级别上运行。执行提交读允许事务读取另一个事务已读取（未修改）的数据，而不必等待第一个事务完成。使用较低的隔离级别（例如提交读）而不使用较高的隔离级别（例如可串行读）可以缩短持有共享锁的时间，从而降低了锁定争夺。

	5、使用绑定连接

	使用绑定连接使同一应用程序所打开的两个或多个连接可以相互合作。次级连接所获得的任何锁可以象由主连接获得的锁那样持有，反之亦然，因此不会相互阻塞。

	6、用存储过程查出引起死锁的进程和SQL语句

	假如发生了死锁，我们怎么去检测具体发生死锁的是哪条SQL语句或存储过程？此时我们可以使用以下存储过程来检测，就可以查出引起死锁的进程和SQL语句。

 

	与锁定有关的两个问题－－死锁和阻塞

	 

	死锁

	死锁是一种条件，不仅仅是在关系数据库管理系统 (RDBMS) 中发生，在任何多用户系统中都可以发生的。当两个用户（或会话）具有不同对象的锁，并且每个用户需要另一个对象的锁时，就会出现死锁。每个用户都等待另一个用户释放他的锁。当两个连接陷入死锁时，Microsoft® SQL Server? 会进行检测。其中一个连接被选作死锁牺牲品。该连接的事务回滚，同时应用程序收到错误。

	如果死锁变成单个公用事件，而且它们的回滚造成过多的性能降级，那么就需要再次进行深入彻底的调查。使用跟踪标记 1204。例如，下面的命令从命令提示符启动 SQL Server，并启用跟踪标记 1204：

	c:\mssql\binn\sqlservr -T1204

	现在所有消息都会显示在启动 SQL Server 的控制台屏幕上和错误日志中。

	使用分布式事务时，也可能发生死锁。

	阻塞

	任何基于锁的并发系统都不可避免地具有可能在某些情况下发生阻塞的特征。当一个连接控制了一个锁，而另一个连接需要冲突的锁类型时，将发生阻塞。其结果是强制第二个连接等待，或在第一个连接上阻塞。

	在本主题中，术语"连接"是指数据库的单个登录会话。每个连接都作为系统进程 ID (SPID) 出现。尽管每一个 SPID 一般都不是单独的进程上下文，但这里常常用来指一个进程。更确切的说，每个 SPID 都是由服务器资源和数据结构（为给定客户单个连接的请求提供服务）组成。单个客户应用程序可能有一个或多个连接。就 SQL Server 而言，从单个客户机上的单个客户应用程序来的多个连接和从多个客户应用程序或多个客户机来的多个连接是没有区别的。不管是来自同一应用程序还是来自两台不同客户机上单独的应用程序，一个连接都可以阻塞另一个连接。
	
003 java里面的锁机制
	
002 数据库乐观锁与悲观锁
	数据的锁定分为两种，第一种叫作悲观锁，第二种叫作乐观锁。

1、悲观锁，就是对数据的冲突采取一种悲观的态度，也就是说假设数据肯定会冲突，所以在数据开始读取的时候就把数据锁定住。【数据锁定：数据将暂时不会得到修改】

2、乐观锁，认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让用户返回错误的信息。让用户决定如何去做。



理解：

1. 乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。

之所以叫乐观，因为这个模式没有从数据库加锁。

2. 悲观锁是读取的时候为后面的更新加锁，之后再来的读操作都会等待。这种是数据库锁

乐观锁优点程序实现，不会存在死锁等问题。他的适用场景也相对乐观。阻止不了除了程序之外的数据库操作。

悲观锁是数据库实现，他阻止一切数据库操作。

再来说更新数据丢失，所有的读锁都是为了保持数据一致性。乐观锁如果有人在你之前更新了，你的更新应当是被拒绝的，可以让用户从新操作。悲观锁则会等待前一个更新完成。这也是区别。具体业务具体分析


这里Hibernate通过使用数据库的for update子句实现了悲观锁机制。对返回的所有user记录进行加锁。
2、Hibernate的加锁模式有：
     Ø LockMode.NONE ： 无锁机制。
     Ø LockMode.WRITE ：Hibernate在写操作（Insert和Update）时会自动获取写锁。
     Ø LockMode.READ ： Hibernate在读取记录的时候会自动获取。
     这三种锁机制一般由Hibernate内部使用，如Hibernate为了保证Update过程中对象不会被外界修改，会在save方法实现中自动为目标对象加上WRITE锁。
     Ø LockMode.UPGRADE ：利用数据库的for update子句加锁。
     Ø LockMode. UPGRADE_NOWAIT ：Oracle的特定实现，利用Oracle的for update nowait子句实现加锁。
     注意，只有在查询开始之前（也就是Hiberate 生成SQL 之前）设定加锁，才会真正通过数据库的锁机制进行加锁处理，否则，数据已经通过不包含for update子句的Select SQL加载进来，所谓数据库加锁也就无从谈起。
3、Hibernate的乐观锁

	     Hibernate 在其数据访问引擎中内置了乐观锁实现。如果不用考虑外部系统对数据库的更新操作，利用Hibernate提供的透明化乐观锁实现，将大大提升我们的生产力。Hibernate中可以通过class描述符的optimistic-lock属性结合version描述符指定。具体实现方式如下：
	     现在，我们为之前示例中的TUser加上乐观锁机制。
	实现一、 配置optimistic-lock属性：

	[html] view plain copy
	<hibernate-mapping>  
	     <class name="org.hibernate.sample.TUser" table="t_user" dynamic-update="true" dynamic-insert="true" optimistic-lock="version">  
	           ……  
	     </class>  
	</hibernate-mapping>  
	optimistic-lock属性有如下可选取值：
	     Ø none：无乐观锁
	     Ø version：通过版本机制实现乐观锁
	     Ø dirty：通过检查发生变动过的属性实现乐观锁
	     Ø all：通过检查所有属性实现乐观锁
	     通过version实现的乐观锁机制是Hibernate官方推荐的乐观锁实现，同时也是Hibernate中，目前唯一在数据对象脱离Session发生修改的情况下依然有效的锁机制。因此，一般情况下，我们都选择version方式作为Hibernate乐观锁实现机制。
	实现二、添加一个Version属性描述符


	[html] view plain copy
	<hibernate-mapping>  
	     <class name="org.hibernate.sample.TUser" table="t_user"   dynamic-update="true" dynamic-insert="true" optimistic-lock="version">   
	    <id name="id" column="id" type="java.lang.Integer">  
	        <generator class="native"/>  
	    </id>  
	    <version column="version" name="version" type="java.lang.Integer"/>  
	……  
	     </class>  
	</hibernate-mapping>  
	     注意version 节点必须出现在ID 节点之后。这里声明了一个version属性，用于存放用户的版本信息，保存在TUser表的version字段中。
	测试：

     此时如果我们尝试编写一段代码，更新TUser表中记录数据，如：

	[html] view plain copy
	Criteria criteria = session.createCriteria(TUser.class);  
	criteria.add(Expression.eq("name","Max"));  
	List userList = criteria.list();  
	TUser user =(TUser)userList.get(0);  
	Transaction tx = session.beginTransaction();  
	user.setUserType(1); //更新UserType字段  
	tx.commit();  
	     每次对TUser进行更新的时候，我们可以发现，数据库中的version都在递增。而如果我们尝试在tx.commit 之前，启动另外一个Session，对名为Max的用户进行操作，下面模拟并发更新时的情况：
	[html] view plain copy
	Session session= getSession();  
	Criteria criteria = session.createCriteria(TUser.class);  
	criteria.add(Expression.eq("name","Max"));  
	Session session2 = getSession();  
	Criteria criteria2 = session2.createCriteria(TUser.class);  
	criteria2.add(Expression.eq("name","Max"));  
	List userList = criteria.list();  
	List userList2 = criteria2.list();TUser user =(TUser)userList.get(0);  
	TUser user2 =(TUser)userList2.get(0);  
	Transaction tx = session.beginTransaction();  
	Transaction tx2 = session2.beginTransaction();  
	user2.setUserType(99);  
	tx2.commit();  
	user.setUserType(1);  
	tx.commit();  
	     执行并发更新的代码，在tx.commit()处抛出StaleObjectStateException异常，并指出版本检查失败，当前事务正在试图提交一个过期数据。通过捕捉这个异常，我们就可以在乐观锁校验失败时进行相应处理。
	     这就是hibernate实现悲观锁和乐观锁的主要方式。

四、总结
     悲观锁相对比较谨慎，设想现实情况应该很容易就发生冲突，所以我还是独占数据资源吧。

     乐观锁就想得开而且非常聪明，应该是不会有什么冲突的，我对表使用一个时间戳或者版本号，每次读、更新操作都对这个字段进行比对，如果在我之前已经有人对数据进行更新了，那就让它更新，大不了我再读一次或者再更新一次。

     乐观锁的管理跟SVN管理代码版本的原理很像，如果在我提交代码之前用本地代码的版本号与服务器做对比，如果本地版本号小于服务器上最新版本号，则提交失败，产生冲突代码，让用户决定选择哪个版本继续使用。
     在实际生产环境里边,如果并发量不大且不允许脏读，可以使用悲观锁；但如果系统的并发非常大的话,悲观锁定会带来非常大的性能问题,所以我们就要选择乐观锁定的方法        另外，Mysql在处理并发访问数据上，还有添加读锁（共享锁）、写锁（排它锁），控制锁粒度【表锁（table lock）、行级锁（row lock）】等实现，有兴趣可以继续研究。
	


001 io和nio的区别
	io				nio
	面向流				面向缓冲区	
	阻塞				非阻塞
	无				选择器
	面向流不能移动流中的数据	面向缓冲可以移动缓冲区的数据

