11 setnx set if not exists 如果不存在,则set,如果存在,就不做任何动作
   setex		   覆盖原来的值 

10 热点key重建优化

        开发人员使用“缓存+过期时间”的策略既可以加速数据读写，又保证数据的定期更新，这种模式基本能够满足绝大部分需求。但是有两个问题如果同时出现，可能就会对应用造成致命的危害：
       ·当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大。

       ·重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的SQL、多次IO、多个依赖等。在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。

        要解决这个问题也不是很复杂，但是不能为了解决这个问题给系统带来更多的麻烦，所以需要制定如下目标：

        ·减少重建缓存的次数

        ·数据尽可能一致。

        ·较少的潜在危险
	
	①互斥锁：此方法只允许一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可，整个过程如图所示。
	1）从Redis获取数据，如果值不为空，则直接返回值；否则执行下面的2.1）和2.2）步骤。

	2.1）如果set（nx和ex）结果为true，说明此时没有其他线程重建缓存，那么当前线程执行缓存构建逻辑。
	2.2）如果set（nx和ex）结果为false，说明此时已经有其他线程正在执行构建缓存的工作，
		那么当前线程将休息指定时间（例如这里是50毫秒，取决于构建缓存的速度）后，重新执行函数，直到获取到数据。
	②永远不过期

	“永远不过期”包含两层意思：
         从缓存层面来看，确实没有设置过期时间，所以不会出现热点key过期后产生的问题，也就是“物理”不过期。

         从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。

    	从实战看，此方法有效杜绝了热点key产生的问题，但唯一不足的就是重构缓存期间，会出现数据不一致的情况，
	这取决于应用方是否容忍这种不一致。

09	
      雪崩优化

        缓存雪崩：由于缓存层承载着大量请求，有效地保护了存储层，但是如果缓存层由于某些原因不能提供服务，
	于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。

        预防和解决缓存雪崩问题，可以从以下三个方面进行着手：

        ①保证缓存层服务高可用性。如果缓存层设计成高可用的，即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，
	例如前面介绍过的Redis Sentinel和Redis Cluster都实现了高可用。

        ②依赖隔离组件为后端限流并降级。在实际项目中，我们需要对重要的资源（例如Redis、MySQL、HBase、外部接口）都进行隔离，
	让每种资源都单独运行在自己的线程池中，即使个别资源出现了问题，对其他服务没有影响。但是线程池如何管理，
	比如如何关闭资源池、开启资源池、资源池阀值管理，这些做起来还是相当复杂的。
	
       ③提前演练。在项目上线前，演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，在此基础上做一些预案设定。
	
08 
      为了满足业务需要可能会添加大量新的缓存节点，但是发现性能不但没有好转反而下降了。
      用一句通俗的话解释就是，更多的节点不代表更高的性能，所谓“无底洞”就是说投入越多不一定产出越多。
      但是分布式又是不可以避免的，因为
      访问量和数据量越来越大，一个节点根本抗不住，所以如何高效地在分布式缓存中批量操作是一个难点。

      无底洞问题分析：
      ①客户端一次批量操作会涉及多次网络操作，也就意味着批量操作会随着节点的增多，耗时会不断增大。

      ②网络连接数变多，对节点的性能也有一定影响。
      
      
      如何在分布式条件下优化批量操作？我们来看一下常见的IO优化思路：

     命令本身的优化，例如优化SQL语句等。
     减少网络通信次数。
     降低接入成本，例如客户端使用长连/连接池、NIO等。

       ①串行命令：由于n个key是比较均匀地分布在Redis Cluster的各个节点上，因此无法使用mget命令一次性获取，
	所以通常来讲要获取n个key的值，最简单的方法就是逐次执行n个get命令，这种操作时间复杂度较高，
	它的操作时间=n次网络时间+n次命令时间，网络次数是n。很显然这种方案不是最优的，但是实现起来比较简单。
	
	②串行IO：Redis Cluster使用CRC16算法计算出散列值，再取对16383的余数就可以算出slot值，
	同时Smart客户端会保存slot和节点的对应关系，有了这两个数据就可以将属于同一个节点的key进行归档，
	得到每个节点的key子列表，之后对每个节点执行mget或者Pipeline操作，
	它的操作时间=node次网络时间+n次命令时间，网络次数是node的个数，整个过程如下图所示，
	很明显这种方案比第一种要好很多，但是如果节点数太多，还是有一定的性能问题。
	
	③并行IO：此方案是将方案2中的最后一步改为多线程执行，网络次数虽然还是节点个数，
		但由于使用多线程网络时间变为O（1），这种方案会增加编程的复杂度。

	④hash_tag实现：Redis Cluster的hash_tag功能，它可以将多个key强制分配到一个节点上，
		它的操作时间=1次网络时间+n次命令时间。

07 穿透优化
     				   		
		
     ②布隆过滤器拦截

        如下图所示，在访问缓存层和存储层之前，将存在的key用布隆过滤器提前保存起来，做第一层拦截。
	例如：一个推荐系统有4亿个用户id，每个小时算法工程师会根据每个用户之前历史行为计算出推荐数据放到存储层中，
	但是最新的用户由于没有历史行为，就会发生缓存穿透的行为，为此可以将所有推荐数据的用户做成布隆过滤器。
	如果布隆过滤器认为该用户id不存在，那么就不会访问存储层，在一定程度保护了存储层。
	
        缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，通常出于容错的考虑，如果从存储层查不到数据则不写入缓存层。

        通常可以在程序中分别统计总调用数、缓存层命中数、存储层命中数，如果发现大量存储层空命中，可能就是出现了缓存穿透问题。
	造成缓存穿透的基本原因有两个。第一，自身业务代码或者数据出现问题，第二，一些恶意攻击、爬虫等造成大量空命中。
	下面我们来看一下如何解决缓存穿透问题。

		另：布隆过滤器简单说明：

	如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，
	然后通过比较确定。链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路。
	但是随着集合中元素的增加，我们需要的存储空间越来越大。同时检索速度也越来越慢。

	Bloom Filter 是一种空间效率很高的随机数据结构，Bloom filter 可以看做是对 bit-map 的扩展, 它的原理是：
	当一个元素被加入集合时，通过 K 个 Hash 函数将这个元素映射成一个位阵列（Bit array）中的 K 个点，
	把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：
	如果这些点有任何一个 0，则被检索元素一定不在；
	如果都是 1，则被检索元素很可能在。

	
     ①缓存空对象：如图下所示，当第2步存储层不命中后，仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取，这样就保护了后端数据源。
	

06 缓存更新策略
	03 
	主动更新：应用方对于数据的一致性要求高，需要在真实数据更新后，
	立即更新缓存数据。例如可以利用消息系统或者其他方式通知缓存更新。
	
	02 
	超时剔除：通过给缓存数据设置过期时间，让其在过期时间后自动删除，例如Redis提供的expire命令。
	如果业务可以容忍一段时间内，缓存层数据和存储层数据不一致，那么可以为其设置过期时间。
	在数据过期后，再从真实数据源获取数据，重新放到缓存并设置过期时间。
	例如一个视频的描述信息，可以容忍几分钟内数据不一致，但是涉及交易方面的业务，后果可想而知。

	01 
	LRU/LFU/FIFO算法剔除：剔除算法通常用于缓存使用量超过了预设的最大值时候，如何对现有的数据进行剔除。
	例如Redis使用maxmemory-policy这个配置作为内存最大值后对于数据的剔除策略。

05 缓存收益与成本
	 1)缓存的收益和成本分析

     下图左侧为客户端直接调用存储层的架构，右侧为比较典型的缓存层+存储层架构。

      下面分析一下缓存加入后带来的收益和成本。
       收益：	加速读写：因为缓存通常都是全内存的，而存储层通常读写性能不够强悍（例如MySQL），通过缓存的使用可以有效地加速读写，优化用户体验。

                降低后端负载：帮助后端减少访问量和复杂计算（例如很复杂的SQL语句），在很大程度降低了后端的负载。

       成本：	数据不一致性：缓存层和存储层的数据存在着一定时间窗口的不一致性，时间窗口跟更新策略有关。
                 代码维护成本：加入缓存后，需要同时处理缓存层和存储层的逻辑，增大了开发者维护代码的成本。

                 运维成本：以Redis Cluster为例，加入后无形中增加了运维成本。
		
	

04 插入数据库没插入缓存如何处理

03 缓存被击穿处理方案

02 redis三高,三危

01 redis为什么这么快
	
